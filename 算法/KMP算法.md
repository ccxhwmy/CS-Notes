## KMP算法

### 步骤

根据搜索词计算部分匹配值

借助部分匹配值进行匹配

### 部分匹配值

​	首先，要了解两个概念：`前缀` 和 `后缀`。前缀指出了最后一个字符以外，一个字符串的全部头部组合；后缀指除了第一个字符以外，一个字符的全部尾部组合。

![img](image/bg2013050109.png)

​	`部分匹配值` 就是 `前缀` 和 `后缀` 的最长的共有元素的长度。以 `ABCDABD` 为例

1. `A` 的前缀和后缀都为空集，共有元素的长度为0；
2. `AB` 的前缀为[A]，后缀为[B]，共有元素的长度为0；
3. `ABC` 的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度为0；
4. `ABCD` 的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；
5. `ABCDA` 的前缀为[A, AB, ABC, ABCD]， 后缀为[BCDA, CDA, DA, A]，共有元素为`A`， 长度为1；
6. `ABCDAB` 的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为`AB`，长度为2；
7. `ABCDABD` 的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0；

​    部分匹配（Partial Match Table）的实质是，有时候，字符串头部和尾部都会有重复。比如：`ABCDAB` 之中有两个`AB`，那么它的部分匹配值就是2。搜索词移动的时候，第一个`AB`向后移动4位（字符串长度-部分匹配值），就可以来到第二个`AB`的位置。

### 匹配计算

![img](image/bg2013050103.png)

​	首先，字符串 `BCC ABCDAB ABCDABCDABDE` 的第一个字符与搜索词 `ABCDABD` 的第一个字符，进行比较。因为 B 与 A 不匹配，所以搜索词后移一位。

![img](image/bg2013050104.png)

​	因为 B 与 A 不匹配，搜索词再往后移。

![img](image/bg2013050105.png)

​	就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。

![img](image/bg2013050106.png)

​	接着比较字符串和搜索词的下一个字符，还是相同。

![img](image/bg2013050107.png)

​	直到字符串有一个字符，与搜索词对应的字符不相同为止。

![img](image/bg2013050108.png)

​	这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把搜索位置移到已经比较过的位置，重比一遍。

![img](image/bg2013050107.png)

​	一个基本的事实是，当空格与D不匹配时，你其实前面六个字符是 `ABCDAB`。KMP 算法的想法是，设法利用这个已知信息，不要把搜索位置移回已经比较过的位置，继续把它向后移，这样就提高了效率。

![img](image/bg2013050109.png)

​	利用已经计算出的 部分匹配表。

![img](image/bg2013050107.png)

​	已知空格与D不匹配时，前面六个字符 `ABCDAB` 是匹配的。查表可知，最后一个匹配字符B对应的部分匹配值为2，因此按照下面的公式算出向后移动的位数：`移动位数 = 已匹配的字符数 - 对应的部分匹配值`。

​	因为 `6 - 2 = 4`，所以将搜索词向后移动 4 位。

![img](image/bg2013050110.png)

​	因为空格与 C 不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（AB），对应的部分匹配值为0。所以，移动位数为 2 - 0，结果为2，于是将搜索词向后移2位。

![img](image/bg2013050111.png)

​	因为空格与A不匹配，继续后移一位。

![img](image/bg2013050112.png)

​	逐位比较，直到发现C与D不匹配。于是，移动位数为 6 - 2，继续将搜索词向后移动 4 位。

![img](image/bg2013050113.png)

​	逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 7 - 0，再将搜索词向后移动 7 位。

### 参考资料

- http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html