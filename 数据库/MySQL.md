## MySQL

### 索引

​	索引是一种特殊的问题检(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

​	索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变种 B+ 树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。

​	MySQL 索引的建立对于 MySQL 的高效运行是很重要的，索引可以大大提高 MySQL 的检索速度。比如我们在查字典的时候，前面都有索引的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个 key 的全部值得信息了。

#### 优缺点

##### 优点

1. 可以大大加快数据得索引速度，这也是创建索引的最主要原因。
2. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
3. 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建的，不需要排序和分组，也就不需要创建临时表）。
4. 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

##### 缺点

1. 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除、和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；
2. 空间方面：索引需要占物理空间。

##### 使用条件

1. 对于非常小的表、大部分情况下简单的全表扫描比建立索引更有效；
2. 对于中到大型的表，索引就非常有效；
3. 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

#### 索引类型

1. 从存储结构划分：BTree 索引（B-Tree 或 B+Tree 索引），Hash索引，full-index 全文索引，R-Tree 索引。这里所描述的是索引存储时保存的形式；
2. 从应用层来分：普通索引，唯一索引，主键索引，组合索引，全文索引。
   - 普通索引：仅加速查询
   - 唯一索引：加速查询 + 列值唯一（可以有null）
   - 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
   - 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
   - 全文索引：对文本的内容进行分词，进行搜索

##### 全文索引

​	MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

​	查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

​	全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

​	InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

##### 空间数据索引

​	MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

​	必须使用 GIS 相关的函数来维护数据。

##### 联合索引

​	MySQL 可以使用多个字段同时建立一个索引，叫作联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为：

​	MySQL 使用索引时需要索引有序，假设现在建立了 "name, age, school" 的联合索引，那么索引的排序为：先按照 name 排下序，如果 name 相同，则按照 age 排序，如果 age 的值也相等，则按照 school 进行排序。

​	当进行查询时，此时索引仅仅按照 name 严格有序，因此必须首先使用 name 字段进行等值查询，之后对于匹配到的列而言，其按照 age 字段严格有序，此时可以使用 age 字段用索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

##### 聚簇索引与非聚簇索引

​	在 InnoDB 里，索引 B+Tree 的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。

​	而索引 B+Tree 的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。

###### 区别

1. 聚簇索引与非聚簇索引的区别在于非聚簇索引的叶子节点不存在表中的数据，而是存储该列对应的主键（行号）
2. 对于 InnoDB 来说，想要查找数据我们还需要根据主键再去聚簇索引中进行查找，这个再根据聚簇索引查找数据的过程，我们称为**回表**。第一次索引一般是顺序 IO，回表的操作属于随机 IO。需要回表的次数越多，即随机 IO 次数越多，我们就越倾向于使用全表扫描。
3. 通常情况下，主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果覆盖索引的话，查一次即可
4. 注意：MyISAM 无论主键索引还是二级索引都是非聚簇索引，而 InnoDB 的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引

![](image/view)

###### 非聚簇索引

​	非聚簇索引不一定会回表查询，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询的字段的值，被称之为“覆盖索引”。

​	举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行 `select score from student where score > 90` 的查询时，在索引的叶子节点上，已经包含了 score 信息，不会再次进行回表查询。

#### 底层实现

##### Hash索引

​	基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且 Hash 索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。

![img](image/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303431313231353031323434332e706e67)

##### B-Tree 索引（MySQL 使用 B+Tree）

​	B-Tree 能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。

![img](image/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303431313231353032333832302e706e67)

##### B+Tree 索引

​	是 B-Tree 的改进版本，同时也是数据库索引所采用的存储结构。数据库都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比 B-Tree 来说，进行范围查找时只需要查找两个节点，进行遍历即可。而 B-Tree 需要获取所有节点，相比之下 B+Tree 效率更高。

B+Tree 性质：

- n 棵子 tree 的节点包含 n 个关键字，不用来保存数据而是保存数据的索引。
- 所有的叶子节点中包含了全部关键字信息，及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接。
- 所有的非终端节点可以看成是索引部分，节点中仅含其子树中的最大（或最小）关键字。
- B+ 树中，数据对象的插入和删除仅在叶子节点上进行。
- B+ 树有 2 个头指针，一个是树的根节点，一个是最小关键码的叶节点。

![img](image/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303431313231353034343333322e706e67)

##### 比较

B-Tree：

1. B+ 树的磁盘读写代价耕地： B+ 树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对 B(B-) 树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对 IO读写次数就降低了。
2. 由于 B+ 树的数据都存储在叶子节点中，分支节点均为索引，方便扫库，只需要扫一遍叶子节点即可，但是 B 树因为分支节点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以 B+ 树更加适合在**区间查询**的情况，所以通常 B+ 树用于数据库索引。

Hash：

1. 虽然可以快速定位，但是没有顺序，IO复杂度高；
2. 基于 Hash 表实现，只有 Memory 存储引擎显式支持哈希索引；
3. 适合**等值查询**，如 `=、in()、<=>`，不支持范围查询；
4. 因为不是按照索引值顺序存储的，就不能像 B+Tree 索引一样利用索引完成排序；
5. Hash 索引在查询等值时非常快；
6. 因为 Hash 索引始终索引的**所有列的全部内容**，所以不支持部分索引列的匹配查找；
7. 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。

二叉树：

​	树的高度不均匀，不能自平衡，查找效率跟数据相关（树的高度），并且 IO 代价高。

红黑树：

​	树的高度随着数据量增加而增加，IO 代价高。



#### 最左前缀原则

​	最左前缀原则是最左优先，在创建多列索引时，要根据业务需求，where 子句中使用最频繁的一列放在最左边。mysql 会一直向右匹配直到遇到范围查询 (>、<、between、like) 就停止匹配，比如 `a = 1 and b = 2 and c = 3 and d = 4` 如果建立 (a,b,c,d) 顺序的索引，d 是用不到索引的，如果建立 (a,b,c,d) 的索引则都可以用到，a,b,d 的顺序可以任意调整。

​	= 和 in 可以乱序，比如 `a = 1 and b = 2 and c = 3` 建立 (a,b,c) 索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。

#### 索引优化

##### 1.独立的列

​	在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

​	例如下面的查询不能使用 actor_id 列的索引：

```mysql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

##### 2.多列索引

​	在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```mysql
SELECT film_id, actor_id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

##### 3.索引列的顺序

​	让选择性最强的索引列放在前面。

​	索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

​	例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引前面。

```mysql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
```

##### 4.前缀索引

​	对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

​	前缀长度的选取需要根据索引选择性来确定。

##### 5.覆盖索引

索引包含所有需要查询的字段的值。

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不适用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

#### Question

多列索引和复合索引的区别

### 查询性能优化

#### 使用 Explain 进行分析

​	Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

​	比较重要的字段有：

- select_type：查询类型，有简单查询、联合查询、子查询等
- key：使用索引
- rows：扫描的行数

#### 优化数据访问

##### 1.减少请求的数据量

- 只返回必要的列：最好不要使用 SELECT * 语句。
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
- 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

##### 2.减少服务器端扫描的行数

​	最有效的方式是使用索引来覆盖查询。

#### 重构查询方式

##### 1.切分大查询

​	一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

```mysql
DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);
```

```sql
rows_affected = 0
do {
	rows_affected = do_query(
	"DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH)
	LIMIT 10000")
} while rows_affected > 0
```

##### 2.分解大连接查询

​	将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其他表的查询缓存依然可以使用。
- 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
- 减少锁竞争。
- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
- 查询本身效率也可能会有所提升。例如在下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比 随机的连接要更高效。

```mysql
SELECT * FROM tab
JOIN TAG_POST ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
```

```mysql
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
```

### 存储引擎

#### InnoDB

​	InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其他存储引擎。

​	实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。

​	主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

​	内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

​	支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

#### MyISAM

​	设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

​	提供了大量的特性，包括压缩表、空间数据索引等。

​	不支持事务。

​	不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

​	如果制定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

#### 比较

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其他特性：MyISAM 支持压缩表和空间数据索引。





### 参考资料

- https://segmentfault.com/a/1190000040177994
- https://blog.51cto.com/u_14286115/5194190
- https://segmentfault.com/a/1190000041290817