## Etcd

#### 概念

etcd是一个分布式、可靠key-value存储的分布式系统，并且还提供共享配置及服务发现；

#### etcd vs Zookeeper

在项目实现、一致性协议易理解性、运维、安全等多个维度上，etcd相比Zookeeper都占优势。

- 一致性协议：etcd使用Raft协议，Zookeeper使用ZAB（类Paxos协议），前者容易理解，方便工程实现；
- 运维方面：etcd方便运维，Zookeeper难以运维；
- 数据存储：etcd多版本并发控制（MVCC）数据模型，支持查询先前版本的键值对；
- 项目活跃度：etcd社区与开发活跃，Zookeeper不活跃；
- API：etcd提供HTTP+JSON，gRPC接口，跨平台语言，Zookeeper需要使用其客户端；
- 访问安全：etcd支持HTTPS访问，Zookeeper不支持；

#### 应用场景

- 配置管理
- 服务器注册发现
- 选主
- 应用调度
- 分布式队列
- 分布式锁

#### 工作原理

##### 如果保证一致性

- etcd集群是一个分布式系统，每个节点都存储了完整的数据；
- 使用Raft协议来维护集群内各个节点状态的一致性；
- 每个节点维护了一个状态机，任意时刻最多存在一个有效的主节点；
- 主节点处理所有来自客户端写操作，通过Raft协议保证写操作对状态机的改动会可靠的同步到其他节点；

##### 数据模型

###### 设计考虑因素

- etcd的设计目标是用来存放非频繁更新的数据，提供可靠的Watch插件；
- 它暴露了键值对的历史版本，以支持低成本的快照、监控历史事件；

###### 要求

- 使用一个持久化的、多版本的、支持并发的数据模型；

###### 实现

- 当etcd键值对的新版本保存后，先前的版本依然存在；
- etcd不会进行in-place的更新操作，而总是生成一个新的数据结构；
- 为了防止历史版本无限增加，etcd的存储支持压缩以及删除老旧版本；

###### 逻辑视图

- etcd存储的是一个扁平的二进制键空间，键空间有一个针对键的词典序索引，因此范围查询的成本较低；
- 键空间维护了多个修订版本，每个原子变动操作都会产生一个新的修订版本，在集群的整个生命周期中，修订版都是单调递增的；
- 修订支持索引；
- 压缩操作需要指定一个修订版本号，小于它的修订版会被移除；
- 一个键的一次生命周期叫做代，删除一个键会创建一个墓碑，将版本设置为0，结束当前代；
- 当压缩时，任何在压缩修订版之前结束的代，都会被移除。值在修订版之前的修改记录（仅保留最后一个）都会被移除；

###### 物理视图

- etcd将数据存储在一个持久化的B+树中，每个修订版仅仅存储相对于前一个修订版的数据状态变化。
- 键值对中的键，是三元组（major，sub，type）：
  - major：存储键值的修订版
  - sub：用于区分相同修订版中的不同键；
  - type：用于特殊值的可选后缀，例如t表示值包含墓碑；
- 键值对的值，包含从上一个修订版的Delta。
- etcd同时在内存中维护了一个B树索引，用于加速针对键的范围扫描。索引的键是物理存储的键面向用户的映射，索引的值则是指向B+树修改点的指针；

#### etcd读写性能

- 2CPU、1.8G内存、SSD磁盘配置下，单节点的写性能可以达到16K QPS，而先写后读也能达到12K QPS

#### 术语

| 术语      | 说明                                           |
| --------- | ---------------------------------------------- |
| Term      | 选举任期，每次选举之后递增                     |
| Vote      | 选举时的一张投票                               |
| Entry     | Raft算法的日志的一个条目                       |
| Candidate | 候选人，参与竞选以期成为下一任期的Leader的节点 |
| Leader    | 领导者，负责主动处理写入请求的节点             |
| Follower  | 跟随者，不负责主动写入，仅仅从Leader同步数据   |
| Commit    | 提交，持久化数据写入到日志中                   |
| Propose   | 提议，请求大部分节点同意数据写入               |

